/**
 * generated by Xtext 2.28.0
 */
package game.of.life.tasks.validation;

import game.of.life.tasks.tASKDSL.Cell;
import game.of.life.tasks.tASKDSL.Game;
import game.of.life.tasks.tASKDSL.GridSize;
import game.of.life.tasks.tASKDSL.StartGrid;
import game.of.life.tasks.tASKDSL.evolutionRules;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class TASKDSLValidator extends AbstractTASKDSLValidator {
  @Check
  public void checkStartGridCoordinates(final Game g) {
    EList<GridSize> gs = g.getGridSize();
    EList<StartGrid> sg = g.getStartGrid();
    for (int i = 0; (i < sg.size()); i++) {
      {
        int height = gs.get(0).getH();
        int length = gs.get(0).getL();
        if (((sg.get(i).getXC() >= height) || (sg.get(i).getXC() < 0))) {
          this.error("X axis out of grid", null);
        }
        if (((sg.get(i).getYC() >= length) || (sg.get(i).getYC() < 0))) {
          this.error("Y axis out of grid", null);
        }
      }
    }
  }

  @Check
  public void checkNoOfTotalCells(final Game g) {
    EList<GridSize> gs = g.getGridSize();
    for (int i = 0; (i < gs.size()); i++) {
      {
        int height = gs.get(0).getH();
        int length = gs.get(0).getL();
        int totalSize = (height * length);
        EList<Cell> cells = g.getAllCells();
        int _size = cells.size();
        boolean _greaterThan = (_size > totalSize);
        if (_greaterThan) {
          this.error("You defined more cells than supposed to be!!", null);
        }
      }
    }
  }

  @Check
  public void checkMinGridSize(final Game g) {
    EList<GridSize> gs = g.getGridSize();
    for (int i = 0; (i < gs.size()); i++) {
      {
        int height = gs.get(0).getH();
        int length = gs.get(0).getL();
        if ((height < 400)) {
          this.error("Height is below minimum grid height!!", null);
        }
        if ((length < 400)) {
          this.error("Length is below minimum grid length!!", null);
        }
      }
    }
  }

  @Check
  public void checkDoubleCoordinates(final Game g) {
    EList<StartGrid> clist = g.getStartGrid();
    for (int i = 0; (i < clist.size()); i++) {
      for (int j = (i + 1); (j < clist.size()); j++) {
        if ((Integer.valueOf(clist.get(i).getXC()).equals(Integer.valueOf(clist.get(j).getXC())) && Integer.valueOf(clist.get(i).getYC()).equals(Integer.valueOf(clist.get(j).getYC())))) {
          this.error("Duplicated Coordinate!!", null);
        }
      }
    }
  }

  public void checkIfCoordinateValuesPositive(final Game g) {
    EList<StartGrid> iaclist = g.getStartGrid();
    for (int i = 0; (i < iaclist.size()); i++) {
      if (((iaclist.get(i).getXC() < 0) || (iaclist.get(i).getYC() < 0))) {
        this.error("Negative Coordinate Not Allowed!!", null);
      }
    }
  }

  public void checkEvolutionRulesForCells(final Game g) {
    EList<evolutionRules> evRules = g.getEvolutionRules();
    for (int i = 0; (i < evRules.size()); i++) {
      {
        int _nNo = evRules.get(i).getNNo();
        boolean _lessThan = (_nNo < 0);
        if (_lessThan) {
          this.error("A cell can not have negative neighbor number. Invalid Rule!!", null);
        }
        int _nNo_1 = evRules.get(i).getNNo();
        boolean _greaterThan = (_nNo_1 > 8);
        if (_greaterThan) {
          this.error("A cell can not have more than 8 neighbors. Invalid Rule!!", null);
        }
      }
    }
  }

  public void checkDuplicateRule(final Game g) {
    EList<evolutionRules> evRules = g.getEvolutionRules();
    for (int i = 0; (i < evRules.size()); i++) {
      for (int j = (i + 1); (j < evRules.size()); j++) {
        if (((Integer.valueOf(evRules.get(i).getNNo()).equals(Integer.valueOf(evRules.get(j).getNNo())) && evRules.get(i).getL().equals(evRules.get(j).getL())) && Integer.valueOf(evRules.get(i).getComparedNo()).equals(Integer.valueOf(evRules.get(j).getComparedNo())))) {
          boolean _equals = evRules.get(i).getResult().equals(evRules.get(j).getResult());
          if (_equals) {
            this.warning("Same Rule replied!!", null);
          } else {
            this.error("Unambogous Rule!!", null);
          }
        }
      }
    }
  }
}
